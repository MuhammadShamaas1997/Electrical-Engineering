#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <complex>
#include "meep.hpp"
#include "ctl-math.h"
#include "ctlgeom.h"
#include "meepgeom.hpp"
#include <math.h>
#ifndef DATADIR
#define DATADIR "./"
#endif

using namespace meep;
using namespace std;





typedef std::complex<double> cdouble;

//SI Conversion Factors
double d0=1e-3;//1mm
double c0=3e8;//Speed of Light (m/s)
double f0=c0/d0;//300GHz
double t0=1/f0;//0.33e-11 (s)
double mu0=4*pi*(1e-7);// (H/m)
double eps0=8.85e-7;// (F/m)



double xcen=0.0, ycen=0.0, zcen=0.0;
double dxmin=0.0, dxmax=0.25, dymin=1.0, dymax=1.5, dzmin=1.0, dzmax=1.5;
double wcore=dymax - dymin;
double winding_thickness_p=0.2, insulation_thickness_p=0.1,pml_thickness=1.0;  
//double sigma_Cu=100000000;
double mu_core=1000;
int Np=1;//must be odd
int Ns=1;//must be odd
double margin=0.1;   
double amplitude=1.0;
double divisions=20;

//Copper
//metal_range = mp.FreqRange(min=um_scale/12.398, max=um_scale/.20664)
double um_scale = 1000.0;//1000um
double eV_um_scale = 1.0/1.23984193;
double Cu_plasma_frq = 10.83*eV_um_scale;
double Cu_f0 = 0.575;
double Cu_frq0 = 1e-10;
double Cu_gam0 = 0.030*eV_um_scale;
double Cu_sig0 = Cu_f0*(Cu_plasma_frq*Cu_plasma_frq)/(Cu_frq0*Cu_frq0);
double Cu_f1 = 0.061;
double Cu_frq1 = 0.291*eV_um_scale;
double Cu_gam1 = 0.378*eV_um_scale;
double Cu_sig1 = Cu_f1*(Cu_plasma_frq*Cu_plasma_frq)/(Cu_frq1*Cu_frq1);
double Cu_f2 = 0.104;
double Cu_frq2 = 2.957*eV_um_scale;      
double Cu_gam2 = 1.056*eV_um_scale;
double Cu_sig2 = Cu_f2*(Cu_plasma_frq*Cu_plasma_frq)/(Cu_frq2*Cu_frq2);
double Cu_f3 = 0.723;
double Cu_frq3 = 5.300*eV_um_scale;      
double Cu_gam3 = 3.213*eV_um_scale;
double Cu_sig3 = Cu_f3*(Cu_plasma_frq*Cu_plasma_frq)/(Cu_frq3*Cu_frq3);
double Cu_f4 = 0.638;
double Cu_frq4 = 11.18*eV_um_scale;
double Cu_gam4 = 4.305*eV_um_scale;
double Cu_sig4 = Cu_f4*(Cu_plasma_frq*Cu_plasma_frq)/(Cu_frq4*Cu_frq4);
double sigma_Cu=Cu_sig0;


//NiFe
//NiFe_range = mp.FreqRange(min=um_scale/0.83, max=um_scale/0.25)
double NiFe_frq = 1/(0.0838297450980392*um_scale);
double NiFe_gam = 1/(0.259381156903766*um_scale);
double NiFe_sig = 1;



double annulus(const vec & v, double xcen, double ycen, double zcen, double dxmin, double dxmax, double dymin, double dymax, double dzmin, double dzmax, double control, double special, double std = 0.0)
{
  double mu=control;

  double dx=v.x() - xcen;
  double dy=v.y() - ycen;
  double dz=v.z() - zcen;

  if ( (abs(dx)<=dxmax) && (abs(dy)<=dymax) && (abs(dz)<=dzmax) )
  {
    {mu= gaussian_random(special,std);}
  }

  if ( (abs(dx)<=dxmin) && (abs(dy)<=dymin) && (abs(dz)<=dzmin) )
  {
    mu= control;
  }

    return mu;  
}

bool inside_box(const vec & v, double xcen, double ycen, double zcen, double dxmax, double dymax, double dzmax)
{
  bool ans=false;

  double dx=v.x() - xcen;
  double dy=v.y() - ycen;
  double dz=v.z() - zcen;


  if ( (abs(dx)<=dxmax) && (abs(dy)<=dymax) && (abs(dz)<=dzmax) )
  {
    {ans=true;}
  }

  return ans;
}

  
cdouble line_integral_x(fields & f, component C, double dx, double xmin, double xmax, double y, double z)
{
  cdouble sum(0.0,0.0);
  cdouble deltax(dx,0.0);
  for (double x=xmin; x<=xmax; x=x+dx)
  {
    monitor_point p;
    f.get_point(&p, vec(x,y,z));
    cdouble dF = p.get_component(C);
    sum += dF*deltax;
  }
  return sum;
}

cdouble line_integral_y(fields & f, component C, double dy, double ymin, double ymax, double x, double z)
{
  cdouble sum(0.0,0.0);
  cdouble deltay(dy,0.0);
  for (double y=ymin; y<=ymax; y=y+dy)
  {
    monitor_point p;
    f.get_point(&p, vec(x,y,z));
    cdouble dF = p.get_component(C);
    sum += dF*deltay;
  }
  return sum;
}

cdouble line_integral_z(fields & f, component C, double dz, double zmin, double zmax, double x, double y)
{
  cdouble sum(0.0,0.0);
  cdouble deltaz(dz,0.0);
  for (double z=zmin; z<=zmax; z=z+dz)
  {
    monitor_point p;
    f.get_point(&p, vec(x,y,z));
    cdouble dF = p.get_component(C);
    //cout<<dF.real()<<" , "<<dF.imag()<<endl;
    sum += dF*deltaz;
    //cout<<dF.real()<<" , "<<dF.imag()<<endl;
  }
  return sum;
}

cdouble compute_Im(fields & f, double y)
{
  cdouble Izf=line_integral_z(f,Ez,0.0001,zcen+dzmin,zcen+dzmax,xcen+dxmax,y);
    cdouble Izb=line_integral_z(f,Ez,0.0001,zcen+dzmin,zcen+dzmax,xcen-dxmax,y);
    cdouble Ixt=line_integral_x(f,Ex,0.0001,xcen-dxmax,xcen+dxmax,y,zcen+dzmax);
    cdouble Ixb=line_integral_x(f,Ex,0.0001,xcen-dxmax,xcen+dxmax,y,zcen+dzmin);
    cdouble Im=Ixt-Izf-Ixb+Izb;
    return Im;
}

cdouble compute_Ie(fields & f, double y)
{
    cdouble Izf=line_integral_z(f,Hz,0.0001,zcen+dzmin,zcen+dzmax,xcen+dxmax,y);
    cdouble Izb=line_integral_z(f,Hz,0.0001,zcen+dzmin,zcen+dzmax,xcen-dxmax,y);
    cdouble Ixt=line_integral_x(f,Hx,0.0001,xcen-dxmax,xcen+dxmax,y,zcen+dzmax);
    cdouble Ixb=line_integral_x(f,Hx,0.0001,xcen-dxmax,xcen+dxmax,y,zcen+dzmin);
    cdouble Ie=Ixt-Izf-Ixb+Izb;
    return Ie;
}

cdouble compute_Vm(fields & f, double y)
{
    cdouble Vy=line_integral_y(f,Hy,0.0001,ycen-dymin,y,xcen,zcen-dzmin);
    cdouble Vz=line_integral_z(f,Hz,0.0001,zcen-dzmin,zcen+dzmin,xcen,y);
    cdouble Vm=Vy+Vz;
    return Vm;
}

cdouble compute_Ve(fields & f, double y)
{
    cdouble Vy=line_integral_y(f,Ey,0.0001,ycen-dymin,y,xcen,zcen-dzmin);
    cdouble Vz=line_integral_z(f,Ez,0.0001,zcen-dzmin,zcen+dzmin,xcen,y);
    cdouble Ve=Vy+Vz;
    return Ve;
}


double mu(const vec &v) 
{
  return annulus(v,xcen,ycen,zcen,dxmin,dxmax,dymin,dymax,dzmin,dzmax,1.0,mu_core,0.0);
}

double eps(const vec &v){
  double dxmax1=dxmax+2*insulation_thickness_p+winding_thickness_p;
  double dxmin1=dxmax;
  double dymax1=dymax+2*insulation_thickness_p+winding_thickness_p;
  double dymin1=dymin-2*insulation_thickness_p-winding_thickness_p;
  double dzmax1=dzmax+2*insulation_thickness_p+winding_thickness_p;
  double dzmin1=dzmin-2*insulation_thickness_p-winding_thickness_p;

  //return annulus(v,xcen,ycen,zcen,dxmin1,dxmax1,dymin1,dymax1,dzmin1,dzmax1,1000.0,1.0,0.0);
  return 3.0;
}

double conductivity(const vec &v) 
{ 
   double sig=1.0;
   double xcenp=xcen; 
    double ycenp=ycen-dymin-(0.5*wcore); 
    double zcenp=zcen;

    double dxminp=dxmax+insulation_thickness_p;
    double dxmaxp=dxminp+winding_thickness_p;
    double dyminp=(0.5*wcore)+insulation_thickness_p; 
    double dymaxp=dyminp+winding_thickness_p;
    double dzminp=0; 
    double dzmaxp=0.5*winding_thickness_p;    
  
    zcenp=zcen-(0.5*double(Np-1)*insulation_thickness_p)-(0.5*double(Np-1)*winding_thickness_p);

    for (int i=0;i<Np;i++)
    {

      if (inside_box(v,xcenp,ycenp,zcenp,dxmaxp,dymaxp,dzmaxp))
    {
      return annulus(v,xcenp,ycenp,zcenp,dxminp,dxmaxp,dyminp,dymaxp,dzminp,dzmaxp,sig,sigma_Cu,10);
    }

    zcenp=zcenp+insulation_thickness_p+winding_thickness_p;     
    }


    ycenp=ycen+dymin+(0.5*wcore); 
    zcenp=zcen-(0.5*double(Ns-1)*insulation_thickness_p)-(0.5*double(Ns-1)*winding_thickness_p);

    for (int i=0;i<Ns;i++)
    {

      if (inside_box(v,xcenp,ycenp,zcenp,dxmaxp,dymaxp,dzmaxp))
    {
      return annulus(v,xcenp,ycenp,zcenp,dxminp,dxmaxp,dyminp,dymaxp,dzminp,dzmaxp,sig,sigma_Cu,10);
    }

    zcenp=zcenp+insulation_thickness_p+winding_thickness_p;     
    }

    return sig;
}


class core_material : public material_function {
  public:
};

class winding_material : public material_function {
  public:
};


typedef struct my_material_func_data {
  double rxInner, ryInner, rOuter;
  bool with_susceptibility;
} my_material_func_data;

/*void my_material_func(vector3 p, void *user_data, meep_geom::medium_struct *m) {
  my_material_func_data *data = (my_material_func_data *)user_data;
  double rxInner = data->rxInner, rxInner2 = rxInner * rxInner;
  double ryInner = data->ryInner, ryInner2 = ryInner * ryInner;
  double rOuter = data->rOuter, rOuter2 = rOuter * rOuter;

  double x = p.x, x2 = x * x, y = p.y, y2 = y * y;

  // test for point inside inner ellipsoid
  bool innermost = ((x2 / rxInner2 + y2 / ryInner2) < 1.0);
  bool outermost = ((x * x + y * y) > rOuter2);
  bool in_middle = (!innermost && !outermost);

  // set permittivity
  double nn = in_middle ? 3.5 : 1.0;
  m->epsilon_diag.x = m->epsilon_diag.y = m->epsilon_diag.z = nn * nn;

  // add susceptibilities (two-oscillator model for Ag)
  if (in_middle && data->with_susceptibility) {
    m->E_susceptibilities.num_items = 2;
    m->E_susceptibilities.items = new meep_geom::susceptibility[2];

    m->E_susceptibilities.items[0].sigma_offdiag.x = 0.0;
    m->E_susceptibilities.items[0].sigma_offdiag.y = 0.0;
    m->E_susceptibilities.items[0].sigma_offdiag.z = 0.0;
    m->E_susceptibilities.items[0].sigma_diag.x = AG_SIG0;
    m->E_susceptibilities.items[0].sigma_diag.y = AG_SIG0;
    m->E_susceptibilities.items[0].sigma_diag.z = AG_SIG0;
    m->E_susceptibilities.items[0].frequency = AG_FRQ0;
    m->E_susceptibilities.items[0].gamma = AG_GAM0;
    m->E_susceptibilities.items[0].noise_amp = 0.0;
    m->E_susceptibilities.items[0].drude = true;
    m->E_susceptibilities.items[0].is_file = false;

    m->E_susceptibilities.items[1].sigma_offdiag.x = 0.0;
    m->E_susceptibilities.items[1].sigma_offdiag.y = 0.0;
    m->E_susceptibilities.items[1].sigma_offdiag.z = 0.0;
    m->E_susceptibilities.items[1].sigma_diag.x = AG_SIG1;
    m->E_susceptibilities.items[1].sigma_diag.y = AG_SIG1;
    m->E_susceptibilities.items[1].sigma_diag.z = AG_SIG1;
    m->E_susceptibilities.items[1].frequency = AG_FRQ1;
    m->E_susceptibilities.items[1].gamma = AG_GAM1;
    m->E_susceptibilities.items[1].noise_amp = 0.0;
    m->E_susceptibilities.items[1].drude = true;
    m->E_susceptibilities.items[1].is_file = false;
  }
}
*/



int main(int argc, char *argv[]) {
  
  initialize mpi(argc,argv);
  const char *mydirname = "MMTL-out";
    std::ofstream Time;
    std::ofstream Space;
    std::ofstream Fields;
    std::ofstream Fluxes;
    Time.open ("TimeEvolution.txt");
    Space.open ("SpaceEvolution.txt");
    Fields.open ("FieldEvolution.txt");
    Fluxes.open ("Flux.txt");
    //trash_output_directory(mydirname);
    double xsize=2*(dxmax+2*insulation_thickness_p+winding_thickness_p+pml_thickness);
    double ysize=2*(dymax+2*insulation_thickness_p+winding_thickness_p+pml_thickness);
    double zsize=2*(dzmax+2*insulation_thickness_p+winding_thickness_p+pml_thickness);
    //double xsize=6, ysize=6, zsize=6;
  
    grid_volume gv = vol3d(xsize, ysize, zsize, divisions);
    //grid_volume vol3d(double xsize, double ysize, double zsize, double a);
    gv.center_origin();
    //void center_origin(void) { shift_origin(-icenter()); }
  
    core_material core_mat;
    structure transformer(gv, core_mat);
    transformer.set_epsilon(eps,true);
    transformer.set_mu(mu,true);
    transformer.add_susceptibility(core_mat, H_stuff, lorentzian_susceptibility(2*pi*NiFe_frq, NiFe_gam, true));
    transformer.add_susceptibility(core_mat, H_stuff, gyrotropic_susceptibility(vec(0.0,0.0,0.0),2*pi*NiFe_frq, NiFe_gam, true));
    //gyrotropic_susceptibility(const vec &bias, double omega_0, double gamma, double alpha = 0.0,gyrotropy_model model = GYROTROPIC_LORENTZIAN);
    //transformer->set_output_directory(mydirname);
    //transformer->set_chi2(mu);
    //transformer->set_chi3(mu);

   /*
  my_material_func_data data;
  data.with_susceptibility = with_susceptibility;
  data.rxInner = R1X;
  data.ryInner = R1Y;
  data.rOuter = R2;

  meep_geom::material_type my_material =meep_geom::make_user_material(my_material_func, (void *)&data, false);

  geometric_object_list g = {0, 0};
  vector3 center = {0, 0, 0};
  bool use_anisotropic_averaging = true;
  bool ensure_periodicity = true;
  meep_geom::set_materials_from_geometry(&the_structure, g, center, use_anisotropic_averaging,DEFAULT_SUBPIXEL_TOL, DEFAULT_SUBPIXEL_MAXEVAL,ensure_periodicity, my_material);
  */

    winding_material winding_mat;
    structure winding(gv, winding_mat);
    //winding.set_epsilon(eps);
    winding.set_conductivity(Ex,conductivity);
    winding.set_conductivity(Ey,conductivity);
    winding.set_conductivity(Ez,conductivity);    
    winding.add_susceptibility(winding_mat, E_stuff, lorentzian_susceptibility(2*pi*Cu_frq0, Cu_gam0, true));
    winding.add_susceptibility(winding_mat, E_stuff, lorentzian_susceptibility(2*pi*Cu_frq1, Cu_gam1));
    winding.add_susceptibility(winding_mat, E_stuff, lorentzian_susceptibility(2*pi*Cu_frq2, Cu_gam2));
    winding.add_susceptibility(winding_mat, E_stuff, lorentzian_susceptibility(2*pi*Cu_frq3, Cu_gam3));
    winding.add_susceptibility(winding_mat, E_stuff, lorentzian_susceptibility(2*pi*Cu_frq4, Cu_gam4));
    //lorentzian_susceptibility(double omega_0, double gamma, bool no_omega_0_denominator = false): omega_0(omega_0), gamma(gamma), no_omega_0_denominator(no_omega_0_denominator)
      


    fields f(& transformer);
    //fields(structure *, double m = 0, double beta = 0, bool zero_fields_near_cylorigin = true);
  


    //f_range;1e-5,1e-2
    double fcen = 0.005; // ; pulse center frequency
    double df = 0.004;    // ; df
    //continuous_src_time src(cdouble(fcen,0));
    gaussian_src_time src(fcen,df);

    double xcenp=xcen; 
    double ycenp=ycen-dymin-(0.5*wcore); 
    double zcenp=zcen;
    double dxminp=dxmax+insulation_thickness_p;
    double dxmaxp=dxminp+winding_thickness_p;
    double dyminp=(0.5*wcore)+insulation_thickness_p; 
    double dymaxp=dyminp+winding_thickness_p;
    double dzminp=0; 
    double dzmaxp=0.5*winding_thickness_p;    
    zcenp=zcen-(0.5*double(Np-1)*insulation_thickness_p)-(0.5*double(Np-1)*winding_thickness_p);

    for (int i=0;i<Np;i++)
    {
      const volume vsrc1 =volume(vec(xcenp+dxmaxp,ycenp-dymaxp,zcenp+dzmaxp), vec(xcenp+dxminp,ycenp+dymaxp,zcenp-dzmaxp));
      const volume vsrc2 =volume(vec(xcenp+dxmaxp,ycenp+dymaxp,zcenp+dzmaxp), vec(xcenp-dxmaxp,ycenp+dyminp,zcenp-dzmaxp));
      const volume vsrc3 =volume(vec(xcenp-dxmaxp,ycenp+dymaxp,zcenp+dzmaxp), vec(xcenp-dxminp,ycenp-dymaxp,zcenp-dzmaxp));
      const volume vsrc4 =volume(vec(xcenp-dxmaxp,ycenp-dyminp,zcenp+dzmaxp), vec(xcenp+dxmaxp,ycenp-dymaxp,zcenp-dzmaxp));
      f.add_volume_source(Ey, src, vsrc1, cdouble(amplitude,0));
      f.add_volume_source(Ex, src, vsrc2, cdouble(-amplitude,0));
      f.add_volume_source(Ey, src, vsrc3, cdouble(-amplitude,0));
      f.add_volume_source(Ex, src, vsrc4, cdouble(amplitude,0));

      zcenp=zcenp+insulation_thickness_p+winding_thickness_p;     
    }
    //void add_point_source(component c, double freq, double width, double peaktime, double cutoff, const vec &, std::complex<double> amp = 1.0, int is_continuous = 0);
    //void add_volume_source(component c, const src_time &src, const volume &, std::complex<double> amp = 1.0);


    xcenp=xcen; 
    ycenp=ycen-dymin-(0.5*wcore); 
    zcenp=zcen;
    volume box1( vec(xcenp+dxminp,ycenp+dyminp,zcenp+dzminp), vec(xcenp-dxminp,ycenp-dyminp,zcenp-dzminp) );
    ycenp=ycen+dymin+(0.5*wcore); 
    volume box2( vec(xcenp+dxminp,ycenp+dyminp,zcenp+dzminp), vec(xcenp-dxminp,ycenp-dyminp,zcenp-dzminp) );
  
    double fmin = fcen-df, fmax = fcen+df;
    int Nfreq = 1/(2*df);
    dft_flux flux1 = f.add_dft_flux_box(box1, fmin, fmax, Nfreq);
    dft_flux flux2 = f.add_dft_flux_box(box2, fmin, fmax, Nfreq);
    double init_energy = f.field_energy_in_box(box1);
   

  /*vec lb(vec()), rb(vec());
  vec lt(vec()), rt(vec());
  flux_vol *left = f.add_flux_plane(lb, lt);
  flux_vol *right = f.add_flux_plane(rb, rt);
  flux_vol *bottom = f.add_flux_plane(lb, rb);
  flux_vol *top = f.add_flux_plane(lt, rt);
  long double fluxL = 0;
  */
  //integral of flux = change in energy of box

    for(int i=1;i<4000;i++)
    {
      f.step();
          //fluxL += f.dt * (left->flux() - right->flux() + bottom->flux() - top->flux());

      if ((i%100)==0)
      {
        cdouble Vm=compute_Im(f,ycen);
        cdouble Im=compute_Im(f,ycen);
        cdouble Ve=compute_Im(f,ycen);
        cdouble Ie=compute_Im(f,ycen);

        monitor_point p;
        f.get_point(&p, vec(xcen,ycen-dymin-0.5*wcore,zcen));
        cdouble H1 = p.get_component(Hx);
        cdouble H2 = p.get_component(Hy);
        cdouble H3 = p.get_component(Hz);
        cdouble B1 = p.get_component(Bx);
        cdouble B2 = p.get_component(By);
        cdouble B3 = p.get_component(Bz);
        cdouble MU1 = p.get_component(Permeability);
        cdouble EPS1 = p.get_component(Dielectric);

        Fields<<H1.real()<<" , "<<H1.imag()<<" , "<<H2.real()<<" , "<<H2.imag()<<" , "<<H3.real()<<" , "<<H3.imag()<<" , "<<B1.real()<<" , "<<B1.imag()<<" , "<<B2.real()<<" , "<<B2.imag()<<" , "<<B3.real()<<" , "<<B3.imag()<<" , "<<MU1.real()<<" , "<<MU1.imag()<<" , "<<EPS1.real()<<" , "<<EPS1.imag()<<endl;
        //Hx , Hy , Hz , Bx , By , Bz , MU , EPS 
        Time<<Im.real()<<" , "<<Im.imag()<<" , "<<Vm.real()<<" , "<<Vm.imag()<<" , "<<Ie.real()<<" , "<<Ie.imag()<<" , "<<Ve.real()<<" , "<<Ve.imag()<<endl;
        //Im , Vm , Ie , Ve 
      }
    }
 
    double *fl1 = flux1.flux();
    double *fl2 = flux2.flux();
    cout<<"Flux Harmonics"<<endl;
    for (int i = 0; i < Nfreq; ++i) {
      Fluxes<<(fmin + i * flux1.dfreq)<<" , "<<fl1[i]<<" , "<<fl2[i]<<endl;
      //freq , fluxin , fluxout
    } 


    cout<<"SpaceEvolution"<<endl;
    for (double y=(ycen-dymin+margin);y<=(ycen+dymin-margin);y=y+margin)  
    {
      cdouble Im=compute_Im(f,y);
      cdouble Ie=compute_Ie(f,y);
      cdouble Vm=compute_Vm(f,y);
      cdouble Ve=compute_Ve(f,y);
      Space <<Im.real()<<" , "<<Im.imag()<<" , "<<Vm.real()<<" , "<<Vm.imag()<<" , "<<Ie.real()<<" , "<<Ie.imag()<<" , "<<Ve.real()<<" , "<<Ve.imag()<<endl;
      //Im , Vm , Ie , Ve 
    }
     

    volume vxy=volume(vec(-xsize,-ysize,0),vec(xsize,ysize,0));
    volume vxz=volume(vec(-xsize,0,-zsize),vec(xsize,0,zsize));
    volume vyz=volume(vec(0,-ysize,-zsize),vec(0,ysize,zsize));
    
    h5file * fEx=f.open_h5file("fEx",h5file::WRITE,0,false);    
    h5file * fEy=f.open_h5file("fEy",h5file::WRITE,0,false);
    h5file * fEz=f.open_h5file("fEz",h5file::WRITE,0,false);
    h5file * fDx=f.open_h5file("fDx",h5file::WRITE,0,false);    
    h5file * fDy=f.open_h5file("fDy",h5file::WRITE,0,false);
    h5file * fDz=f.open_h5file("fDz",h5file::WRITE,0,false);
    h5file * fHx=f.open_h5file("fHx",h5file::WRITE,0,false);    
    h5file * fHy=f.open_h5file("fHy",h5file::WRITE,0,false);
    h5file * fHz=f.open_h5file("fHz",h5file::WRITE,0,false);
    h5file * fBx=f.open_h5file("fBx",h5file::WRITE,0,false);    
    h5file * fBy=f.open_h5file("fBy",h5file::WRITE,0,false);
    h5file * fBz=f.open_h5file("fBz",h5file::WRITE,0,false);
    
    f.output_hdf5(Dielectric,vyz,fEx);
    f.output_hdf5(Permeability,vyz,fEy);
    f.output_hdf5(Ez,vxz,fEz);
    f.output_hdf5(Dx,vxz,fDx);
    f.output_hdf5(Dy,vxz,fDy);
    f.output_hdf5(Dz,vxz,fDz);
    f.output_hdf5(Hx,vyz,fHx);
    f.output_hdf5(Hy,vyz,fHy);
    f.output_hdf5(Hz,vyz,fHz);
    f.output_hdf5(Bx,vyz,fBx);
    f.output_hdf5(By,vyz,fBy);
    f.output_hdf5(Bz,vyz,fBz);

    Time.close();
    Space.close();
    Fields.close();
    Fluxes.close();
    return 0;
}
