#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <complex>
#include "meep.hpp"
#include "ctl-math.h"
#include "ctlgeom.h"
#include "meepgeom.hpp"

#ifndef DATADIR
#define DATADIR "./"
#endif

using namespace meep;
using namespace std;

typedef std::complex<double> cdouble;

double xcen=0.0, ycen=0.0, zcen=0.0;
double dxmin=0.0, dxmax=0.5,dymin=1.5, dymax=2.5,dzmin=1.5, dzmax=2.5;
double wcore=dymax - dymin;
double winding_thickness_p=0.1, insulation_thickness_p=0.2,pml_thickness=1.0;  
double sigma_Cu=100000000;
double mu_core=100;
int Np=3;//must be odd
int Ns=3;//must be odd
double margin=0.1;   

double annulus(const vec & v, double xcen, double ycen, double zcen, double dxmin, double dxmax, double dymin, double dymax, double dzmin, double dzmax, double control, double special, double std = 0.0)
{
	double mu=control;

	double dx=v.x() - xcen;
	double dy=v.y() - ycen;
	double dz=v.z() - zcen;

	if ( (abs(dx)<=dxmax) && (abs(dy)<=dymax) && (abs(dz)<=dzmax) )
	{
		{mu= gaussian_random(special,std);}
	}

	if ( (abs(dx)<=dxmin) && (abs(dy)<=dymin) && (abs(dz)<=dzmin) )
	{
		mu= control;
	}

    return mu;	
}

bool inside_box(const vec & v, double xcen, double ycen, double zcen, double dxmax, double dymax, double dzmax)
{
	bool ans=false;

	double dx=v.x() - xcen;
	double dy=v.y() - ycen;
	double dz=v.z() - zcen;


	if ( (abs(dx)<=dxmax) && (abs(dy)<=dymax) && (abs(dz)<=dzmax) )
	{
		{ans=true;}
	}

	return ans;
}

double eps(const vec &v) {return 1.0;}


double mu(const vec &v) 
{
	return annulus(v,xcen,ycen,zcen,dxmin,dxmax,dymin,dymax,dzmin,dzmax,1.0,mu_core,0.0);
}

double conductivity(const vec &v) 
{	
	double sig=0.0;
	double xcenp=xcen; 
    double ycenp=ycen-dymin-(0.5*wcore); 
    double zcenp=zcen;

    double dxminp=dxmax+insulation_thickness_p;
    double dxmaxp=dxminp+winding_thickness_p;
    double dyminp=(0.5*wcore)+insulation_thickness_p; 
    double dymaxp=dyminp+winding_thickness_p;
    double dzminp=0; 
    double dzmaxp=0.5*winding_thickness_p;    
	
	zcenp=zcen-(0.5*double(Np-1)*insulation_thickness_p)-(0.5*double(Np-1)*winding_thickness_p);

    for (int i=0;i<Np;i++)
    {

    	if (inside_box(v,xcenp,ycenp,zcenp,dxmaxp,dymaxp,dzmaxp))
		{
			return annulus(v,xcenp,ycenp,zcenp,dxminp,dxmaxp,dyminp,dymaxp,dzminp,dzmaxp,sig,sigma_Cu,10);
		}

		zcenp=zcenp+insulation_thickness_p+winding_thickness_p;    	
    }


	ycenp=ycen+dymin+(0.5*wcore); 
    zcenp=zcen-(0.5*double(Ns-1)*insulation_thickness_p)-(0.5*double(Ns-1)*winding_thickness_p);

    for (int i=0;i<Ns;i++)
    {

	    if (inside_box(v,xcenp,ycenp,zcenp,dxmaxp,dymaxp,dzmaxp))
		{
			return annulus(v,xcenp,ycenp,zcenp,dxminp,dxmaxp,dyminp,dymaxp,dzminp,dzmaxp,sig,sigma_Cu,10);
		}

		zcenp=zcenp+insulation_thickness_p+winding_thickness_p;    	
    }

    return sig;
}
  
cdouble line_integral_x(fields & f, component C, double dx, double xmin, double xmax, double y, double z)
{
	cdouble sum(0.0,0.0);
	cdouble deltax(dx,0.0);
	for (double x=xmin; x<=xmax; x=x+dx)
	{
		monitor_point p;
		f.get_point(&p, vec(x,y,z));
		cdouble dF = p.get_component(C);
		sum += dF*deltax;
	}
	return sum;
}

cdouble line_integral_y(fields & f, component C, double dy, double ymin, double ymax, double x, double z)
{
	cdouble sum(0.0,0.0);
	cdouble deltay(dy,0.0);
	for (double y=ymin; y<=ymax; y=y+dy)
	{
		monitor_point p;
		f.get_point(&p, vec(x,y,z));
		cdouble dF = p.get_component(C);
		sum += dF*deltay;
	}
	return sum;
}

cdouble line_integral_z(fields & f, component C, double dz, double zmin, double zmax, double x, double y)
{
	cdouble sum(0.0,0.0);
	cdouble deltaz(dz,0.0);
	for (double z=zmin; z<=zmax; z=z+dz)
	{
		monitor_point p;
		f.get_point(&p, vec(x,y,z));
		cdouble dF = p.get_component(C);
		//cout<<dF.real()<<" , "<<dF.imag()<<endl;
		sum += dF*deltaz;
		//cout<<dF.real()<<" , "<<dF.imag()<<endl;
	}
	return sum;
}

cdouble compute_Im(fields & f, double y)
{
	cdouble Izf=line_integral_z(f,Ez,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen+dxmax+margin,y);
    cdouble Izb=line_integral_z(f,Ez,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen-dxmax-margin,y);
    cdouble Ixt=line_integral_x(f,Ex,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmax+margin);
    cdouble Ixb=line_integral_x(f,Ex,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmin-margin);
    cdouble Im=Ixt-Izf-Ixb+Izb;
    return Im;
}

cdouble compute_Ie(fields & f, double y)
{
	cdouble Izf=line_integral_z(f,Hz,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen+dxmax+margin,y);
    cdouble Izb=line_integral_z(f,Hz,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen-dxmax-margin,y);
    cdouble Ixt=line_integral_x(f,Hx,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmax+margin);
    cdouble Ixb=line_integral_x(f,Hx,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmin-margin);
    cdouble Ie=Ixt-Izf-Ixb+Izb;
    return Ie;
}

cdouble compute_Vm(fields & f, double y)
{
	cdouble Vy=line_integral_y(f,Hy,0.0001,ycen-dymin+margin,y,xcen,zcen-dzmin);
    cdouble Vz=line_integral_z(f,Hz,0.0001,zcen-dzmin,zcen+dzmin,xcen,y);
    cdouble Vm=Vy+Vz;
    return Vm;
}

cdouble compute_Ve(fields & f, double y)
{
	cdouble Vy=line_integral_y(f,Ey,0.0001,ycen-dymin+margin,y,xcen,zcen-dzmin);
    cdouble Vz=line_integral_z(f,Ez,0.0001,zcen-dzmin,zcen+dzmin,xcen,y);
    cdouble Ve=Vy+Vz;
    return Ve;
}

int main(int argc, char *argv[]) {
	initialize mpi(argc, argv);

	const char *mydirname = "MMTL-out";
	std::ofstream myfile;
	std::ofstream myfile1;
	std::ofstream Fields;
  	myfile.open ("TimeEvolution.txt");
  	myfile1.open ("SpaceEvolution.txt");
  	Fields.open ("FieldEvolution.txt");
  	
	//trash_output_directory(mydirname);
	double resolution=1.0;
	double xsize=10.0,ysize=10.0,zsize=10.0;
	grid_volume gv = vol3d(xsize, ysize, zsize, resolution);
	//grid_volume vol3d(double xsize, double ysize, double zsize, double a);
  	gv.center_origin();
  	//void center_origin(void) { shift_origin(-icenter()); }
  
 
  	structure *transformer = new structure(gv, eps, pml(pml_thickness));
  	//transformer->set_output_directory(mydirname);
  	transformer->set_mu(mu);
  	transformer->set_conductivity(Ex,conductivity);
  	transformer->set_conductivity(Ey,conductivity);
  	transformer->set_conductivity(Ez,conductivity);
  	//transformer->set_chi2(mu);
  	//transformer->set_chi3(mu);
  	//transformer->add_susceptibility(transformer_material, E_stuff, lorentzian_susceptibility(1.1, 1e-5));
	//lorentzian_susceptibility(double omega_0, double gamma, bool no_omega_0_denominator = false): omega_0(omega_0), gamma(gamma), no_omega_0_denominator(no_omega_0_denominator)
      


  	fields f(transformer);
  	//fields(structure *, double m = 0, double beta = 0, bool zero_fields_near_cylorigin = true);
  



  	double fcen = 15; // ; pulse center frequency
  	double df = 0.01;    // ; df
  	gaussian_src_time src(fcen, df);
  	for (int Np=1;Np<2;Np++)
  	{
    	//ycenp=ycen+Np*2*winding_thickness_p+2*Np*insulation_thickness_p; 
    	//const volume vsrc1 =volume(vec(xcenp+dxmaxp,ycenp+dymaxp,zcenp-dzmaxp), vec(xcenp+dxminp,ycenp-dymaxp,zcenp+dzmaxp));
    	//const volume vsrc2 =volume(vec(xcenp-dxmaxp,ycenp+dymaxp,zcenp-dzmaxp), vec(xcenp-dxminp,ycenp-dymaxp,zcenp+dzmaxp));
    	//const volume vsrc3 =volume(vec(xcenp+dxminp,ycenp+dymaxp,zcenp-dzmaxp), vec(xcenp-dxminp,ycenp-dymaxp,zcenp-dzminp));
    	//const volume vsrc4 =volume(vec(xcenp+dxminp,ycenp+dymaxp,zcenp+dzminp), vec(xcenp-dxminp,ycenp-dymaxp,zcenp+dzmaxp));
    	//f.add_volume_source(Ey, src,  vsrc1);
		//void add_volume_source(component c, const src_time &src, const volume &, std::complex<double> amp = 1.0);
    	//f.add_volume_source(Ey, src, vsrc2);
    	//f.add_volume_source(Ex, src, vsrc3);
    	//f.add_volume_source(Ex, src, vsrc4);
    	//f.add_point_source(Ex,src,vec(0,-2.505,0));
  	}

	f.add_point_source(Ex, 0.0001, 0.000001, 0.0, 100.0, vec(0.0,-2.505,0.0), cdouble(0.001,0),1);
  	//void add_point_source(component c, double freq, double width, double peaktime, double cutoff, const vec &, std::complex<double> amp = 1.0, int is_continuous = 0);

    for(int i=1;i<1000;i++)
    {
    	f.step();
    	cdouble Vm=compute_Im(f,ycen);
    	cdouble Im=compute_Im(f,ycen);
    	cdouble Ve=compute_Im(f,ycen);
    	cdouble Ie=compute_Im(f,ycen);

		monitor_point p;
		f.get_point(&p, vec(xcen,ycen-dymin-0.5*wcore,zcen));
		cdouble H1 = p.get_component(Hx);
		cdouble H2 = p.get_component(Hy);
		cdouble H3 = p.get_component(Hz);
		cdouble B1 = p.get_component(Bx);
		cdouble B2 = p.get_component(By);
		cdouble B3 = p.get_component(Bz);

		Fields<<H1.real()<<" , "<<H1.imag()<<" , "<<H2.real()<<" , "<<H2.imag()<<" , "<<H3.real()<<" , "<<H3.imag()<<" , "<<B1.real()<<" , "<<B1.imag()<<" , "<<B2.real()<<" , "<<B2.imag()<<" , "<<B3.real()<<" , "<<B3.imag()<<endl;

    	myfile<<Im.real()<<" , "<<Im.imag()<<" , "<<Vm.real()<<" , "<<Vm.imag()<<" , "<<Ie.real()<<" , "<<Ie.imag()<<" , "<<Ve.real()<<" , "<<Ve.imag()<<endl;
  		
    }
	
	cout<<"Im(re) , Im(im)"<<endl;
	
	double y=ycen;
	for (double y=(ycen-dymin+margin);y<=(ycen+dymin-margin);y=y+0.1)
	{
		
		//cdouble Izf=line_integral_z(f,Ez,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen+dxmax+margin,y);
    	//cdouble Izb=line_integral_z(f,Ez,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen-dxmax-margin,y);
    	//cdouble Ixt=line_integral_x(f,Ex,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmax+margin);
    	//cdouble Ixb=line_integral_x(f,Ex,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmin-margin);
    	//cdouble Im=Ixt-Izf-Ixb+Izb;
    	cdouble Im=compute_Im(f,y);
    	
    
		//Izf=line_integral_z(f,Hz,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen+dxmax+margin,y);
    	//Izb=line_integral_z(f,Hz,0.0001,zcen+dzmin-margin,zcen+dzmax+margin,xcen-dxmax-margin,y);
    	//Ixt=line_integral_x(f,Hx,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmax+margin);
    	//Ixb=line_integral_x(f,Hx,0.0001,xcen-dxmax-margin,xcen+dxmax+margin,y,zcen+dzmin-margin);
    	//Ie=Ixt-Izf-Ixb+Izb;
    	cdouble Ie=compute_Ie(f,y);

    
    	//cdouble Vy=line_integral_y(f,Hy,0.0001,ycen-dymin+margin,y,xcen,zcen-dzmin);
    	//cdouble Vz=line_integral_z(f,Hz,0.0001,zcen-dzmin,zcen+dzmin,xcen,y);
    	//cdouble Vm=Vy+Vz;
    	cdouble Vm=compute_Vm(f,y);

    
    	//Vy=line_integral_y(f,Ey,0.0001,ycen-dymin+margin,y,xcen,zcen-dzmin);
    	//Vz=line_integral_z(f,Ez,0.0001,zcen-dzmin,zcen+dzmin,xcen,y);
    	//Ve=Vy+Vz;
    	cdouble Ve=compute_Ve(f,y);

    	myfile1 <<Im.real()<<" , "<<Im.imag()<<" , "<<Vm.real()<<" , "<<Vm.imag()<<" , "<<Ie.real()<<" , "<<Ie.imag()<<" , "<<Ve.real()<<" , "<<Ve.imag()<<endl;
    
	}
    

	volume vxy=volume(vec(-5,-5,0),vec(5,5,0));
	volume vxz=volume(vec(-5,-2,-5),vec(5,-2,5));
	volume vyz=volume(vec(0,-5,-5),vec(0,5,5));
    
    h5file * fileEz1=f.open_h5file("MMTLEz1",h5file::WRITE,0,false);    
    h5file * fileEz2=f.open_h5file("MMTLEz2",h5file::WRITE,0,false);
    h5file * fileEz3=f.open_h5file("MMTLEz3",h5file::WRITE,0,false);
    
    f.output_hdf5(Hx,vyz,fileEz1);
    f.output_hdf5(Hy,vyz,fileEz2);
    f.output_hdf5(Hz,vyz,fileEz3);

myfile.close();
myfile1.close();
Fields.close();
  return 0;
}
